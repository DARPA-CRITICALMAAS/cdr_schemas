


# CDR Schemas


## Development

Formatting Code
```
poetry run format
```


Verify Changes
```
# verify types (mypy)
poetry run types

# lint
poetry run lint
```

Build local package

```
poetry build -f sdist
```


Update Schema Diagrams

To generate schemas you will need to run `poetry install --with docs` to install the proper dependencies

```
poetry run docs
```

<!--#+BEGIN_SCHEMA-->
<!-- this sections is autogenerated -->



## Schemas

   [Area Extraction](#Area-Extraction)<br/>
   [Cog Metadata](#Cog-Metadata)<br/>
   [Document](#Document)<br/>
   [Feature Results](#Feature-Results)<br/>
   [Georeference](#Georeference)<br/>
   [Line Feature](#Line-Feature)<br/>
   [Map](#Map)<br/>
   [Map Results](#Map-Results)<br/>
   [Metadata](#Metadata)<br/>
   [Mineral](#Mineral)<br/>
   [Point Feature](#Point-Feature)<br/>
   [Polygon Feature](#Polygon-Feature)<br/>
   [Prospectivity Input](#Prospectivity-Input)<br/>
   [Prospectivity Models](#Prospectivity-Models)<br/>



### Area Extraction

<details open>
    <summary>area extraction</summary>

```mermaid
classDiagram

    class AreaType {
        <<Enumeration>>
        Map_Area: str = 'map_area'
        Legend_Area: str = 'legend_area'
        CrossSection: str = 'cross_section'
        OCR: str = 'ocr'
        Polygon_Legend_Area: str = 'polygon_legend_area'
        Line_Point_Legend_Area: str = 'line_point_legend_area'
        Line_Legend_Area: str = 'line_legend_area'
        Point_Legend_Area: str = 'point_legend_area'
        Correlation_Diagram: str = 'correlation_diagram'
    }

    class GeomType {
        <<Enumeration>>
        Point: str = 'Point'
        LineString: str = 'LineString'
        Polygon: str = 'Polygon'
    }

    class Area_Extraction {
        type: GeomType = GeomType.Polygon
        coordinates: list[list[list[Union[float, int]]]]
        bbox: list[Union[float, int]] = list
        category: AreaType
        text: str = ''
        reference_id: str = ''
        validated: bool = False
        model: str
        model_version: str
        confidence: Union[float, int, NoneType] = None
    }

    Area_Extraction ..> AreaType
    Area_Extraction ..> GeomType


```

</details>

### Georeference

<details open>
    <summary>georeference</summary>

```mermaid
classDiagram

    class Pixel_Point {
        rows_from_top: Union[float, int]
        columns_from_left: Union[float, int]
        type: GeomType = GeomType.Point
    }

    class GeoreferenceResults {
        cog_id: str
        georeference_results: list[GeoreferenceResult] = list
        gcps: list[GroundControlPoint] = list
        system: str
        system_version: str
    }

    class GeomType {
        <<Enumeration>>
        Point: str = 'Point'
        LineString: str = 'LineString'
        Polygon: str = 'Polygon'
    }

    class GeoreferenceResult {
        likely_CRSs: list[str] = list
        map_area: Optional[Area_Extraction] = None
        projections: list[ProjectionResult] = list
    }

    class Geom_Point {
        latitude: Union[float, int, NoneType]
        longitude: Union[float, int, NoneType]
        type: GeomType = GeomType.Point
    }

    class GroundControlPoint {
        gcp_id: str
        map_geom: Geom_Point
        px_geom: Pixel_Point
        confidence: Union[float, int, NoneType] = None
        model: str
        model_version: str
        crs: str
    }

    class ProjectionResult {
        crs: str
        gcp_ids: list[str]
        file_name: str
        validated: bool = False
    }

    class Area_Extraction {
        type: GeomType = GeomType.Polygon
        coordinates: list[list[list[Union[float, int]]]]
        bbox: list[Union[float, int]] = list
        category: AreaType
        text: str = ''
        reference_id: str = ''
        validated: bool = False
        model: str
        model_version: str
        confidence: Union[float, int, NoneType] = None
    }

    Area_Extraction ..> AreaType
    Area_Extraction ..> GeomType
    Geom_Point ..> GeomType
    Pixel_Point ..> GeomType
    GroundControlPoint ..> Pixel_Point
    GroundControlPoint ..> Geom_Point
    GeoreferenceResult ..> Area_Extraction
    GeoreferenceResult ..> ProjectionResult
    GeoreferenceResults ..> GroundControlPoint
    GeoreferenceResults ..> GeoreferenceResult


```

</details>

### Metadata

<details open>
    <summary>metadata</summary>

```mermaid
classDiagram

    class MapMetaData {
        title: str = ''
        year: Optional[int] = None
        crs: str = ''
        authors: list[str] = list
        organization: str = ''
        scale: Optional[int] = None
        quadrangle_name: str = ''
        map_shape: Optional[MapShapeTypes] = None
        map_color_scheme: Optional[MapColorSchemeTypes] = None
        publisher: str = ''
        state: str = ''
        model: str
        model_version: str
    }

    class MapShapeTypes {
        <<Enumeration>>
        rectangular: str = 'rectangular'
        non_rectangular: str = 'non_rectangular'
    }

    class MapColorSchemeTypes {
        <<Enumeration>>
        full_color: str = 'full_color'
        monochrome: str = 'monochrome'
        grayscale: str = 'grayscale'
    }

    class CogMetaData {
        cog_id: str
        system: str
        system_version: str
        multiple_maps: Optional[bool] = None
        map_metadata: list[MapMetaData] = list
    }

    MapMetaData ..> MapShapeTypes
    MapMetaData ..> MapColorSchemeTypes
    CogMetaData ..> MapMetaData


```

</details>

### Feature Results

<details open>
    <summary>feature results</summary>

```mermaid
classDiagram

    class PolygonLegendAndFeaturesResult {
        id: str
        legend_provenance: Optional[ModelProvenance] = None
        label: str
        abbreviation: str = ''
        description: str = ''
        legend_bbox: list[Union[float, int]] = list
        legend_contour: list[list[Union[float, int]]] = list
        color: str = ''
        pattern: str = ''
        category: str = ''
        map_unit: Optional[MapUnit] = None
        reference_id: str = ''
        validated: bool = False
        crs: str = 'pixel'
        cdr_projection_id: str = ''
        polygon_features: Optional[PolygonFeatureCollection] = None
    }

    class PointLegendAndFeaturesResult {
        id: str
        legend_provenance: Optional[ModelProvenance] = None
        name: str
        abbreviation: str = ''
        description: str = ''
        legend_bbox: list[Union[float, int]] = list
        legend_contour: list[list[Union[float, int]]] = list
        reference_id: str = ''
        validated: bool = False
        crs: str = 'pixel'
        cdr_projection_id: str = ''
        point_features: Optional[PointFeatureCollection] = None
    }

    class LineLegendAndFeaturesResult {
        id: str
        legend_provenance: Optional[ModelProvenance] = None
        name: str = ''
        abbreviation: str = ''
        description: str = ''
        legend_bbox: list[Union[float, int]] = list
        legend_contour: list[list[Union[float, int]]] = list
        reference_id: str = ''
        validated: bool = False
        crs: str = 'pixel'
        cdr_projection_id: str = ''
        line_features: Optional[LineFeatureCollection] = None
    }

    class FeatureResults {
        system: str
        system_version: str
        cog_id: str
        line_feature_results: list[LineLegendAndFeaturesResult] = list
        point_feature_results: list[PointLegendAndFeaturesResult] = list
        polygon_feature_results: list[PolygonLegendAndFeaturesResult] = list
        cog_area_extractions: list[Area_Extraction] = list
        cog_metadata_extractions: list[CogMetaData] = list
    }

    class CogMetaData {
        cog_id: str
        system: str
        system_version: str
        multiple_maps: Optional[bool] = None
        map_metadata: list[MapMetaData] = list
    }

    class Area_Extraction {
        type: GeomType = GeomType.Polygon
        coordinates: list[list[list[Union[float, int]]]]
        bbox: list[Union[float, int]] = list
        category: AreaType
        text: str = ''
        reference_id: str = ''
        validated: bool = False
        model: str
        model_version: str
        confidence: Union[float, int, NoneType] = None
    }

    Area_Extraction ..> AreaType
    Area_Extraction ..> GeomType
    LineLegendAndFeaturesResult ..> ModelProvenance
    LineLegendAndFeaturesResult ..> LineFeatureCollection
    PointLegendAndFeaturesResult ..> ModelProvenance
    PointLegendAndFeaturesResult ..> PointFeatureCollection
    PolygonLegendAndFeaturesResult ..> PolygonFeatureCollection
    PolygonLegendAndFeaturesResult ..> ModelProvenance
    PolygonLegendAndFeaturesResult ..> MapUnit
    CogMetaData ..> MapMetaData
    FeatureResults ..> PolygonLegendAndFeaturesResult
    FeatureResults ..> PointLegendAndFeaturesResult
    FeatureResults ..> LineLegendAndFeaturesResult
    FeatureResults ..> CogMetaData
    FeatureResults ..> Area_Extraction


```

</details>

### Point Feature

<details open>
    <summary>point feature</summary>

```mermaid
classDiagram

    class PointLegendAndFeaturesResult {
        id: str
        legend_provenance: Optional[ModelProvenance] = None
        name: str
        abbreviation: str = ''
        description: str = ''
        legend_bbox: list[Union[float, int]] = list
        legend_contour: list[list[Union[float, int]]] = list
        reference_id: str = ''
        validated: bool = False
        crs: str = 'pixel'
        cdr_projection_id: str = ''
        point_features: Optional[PointFeatureCollection] = None
    }

    class PointProperties {
        model: str
        model_version: str
        confidence: Union[float, int, NoneType] = None
        bbox: Optional[list[Union[float, int]]] = None
        dip: Optional[int] = None
        dip_direction: Optional[int] = None
        reference_id: str = ''
        validated: bool = False
    }

    class PointFeatureCollection {
        type: GeoJsonType = GeoJsonType.FeatureCollection
        features: list[PointFeature] = list
    }

    class GeomType {
        <<Enumeration>>
        Point: str = 'Point'
        LineString: str = 'LineString'
        Polygon: str = 'Polygon'
    }

    class ModelProvenance {
        model: str
        model_version: str
        confidence: Union[float, int, NoneType] = None
    }

    class Point {
        coordinates: list[Union[float, int]]
        type: GeomType = GeomType.Point
    }

    class GeoJsonType {
        <<Enumeration>>
        Feature: str = 'Feature'
        FeatureCollection: str = 'FeatureCollection'
    }

    class PointFeature {
        type: GeoJsonType = GeoJsonType.Feature
        id: str
        geometry: Point
        properties: PointProperties
    }

    Point ..> GeomType
    PointFeature ..> Point
    PointFeature ..> PointProperties
    PointFeature ..> GeoJsonType
    PointFeatureCollection ..> GeoJsonType
    PointFeatureCollection ..> PointFeature
    PointLegendAndFeaturesResult ..> ModelProvenance
    PointLegendAndFeaturesResult ..> PointFeatureCollection


```

</details>

### Line Feature

<details open>
    <summary>line feature</summary>

```mermaid
classDiagram

    class LineProperty {
        model: str
        model_version: str
        confidence: Union[float, int, NoneType] = None
        dash_pattern: Optional[DashType] = None
        symbol: str = ''
        reference_id: str = ''
        validated: bool = False
    }

    class LineLegendAndFeaturesResult {
        id: str
        legend_provenance: Optional[ModelProvenance] = None
        name: str = ''
        abbreviation: str = ''
        description: str = ''
        legend_bbox: list[Union[float, int]] = list
        legend_contour: list[list[Union[float, int]]] = list
        reference_id: str = ''
        validated: bool = False
        crs: str = 'pixel'
        cdr_projection_id: str = ''
        line_features: Optional[LineFeatureCollection] = None
    }

    class Line {
        coordinates: list[list[Union[float, int]]]
        type: GeomType = GeomType.LineString
    }

    class GeomType {
        <<Enumeration>>
        Point: str = 'Point'
        LineString: str = 'LineString'
        Polygon: str = 'Polygon'
    }

    class ModelProvenance {
        model: str
        model_version: str
        confidence: Union[float, int, NoneType] = None
    }

    class LineFeature {
        type: GeoJsonType = GeoJsonType.Feature
        id: str
        geometry: Line
        properties: LineProperty
    }

    class DashType {
        <<Enumeration>>
        solid: str = 'solid'
        dash: str = 'dash'
        dotted: str = 'dotted'
    }

    class GeoJsonType {
        <<Enumeration>>
        Feature: str = 'Feature'
        FeatureCollection: str = 'FeatureCollection'
    }

    class LineFeatureCollection {
        type: GeoJsonType = GeoJsonType.FeatureCollection
        features: list[LineFeature] = list
    }

    Line ..> GeomType
    LineProperty ..> DashType
    LineFeature ..> LineProperty
    LineFeature ..> GeoJsonType
    LineFeature ..> Line
    LineFeatureCollection ..> GeoJsonType
    LineFeatureCollection ..> LineFeature
    LineLegendAndFeaturesResult ..> ModelProvenance
    LineLegendAndFeaturesResult ..> LineFeatureCollection


```

</details>

### Polygon Feature

<details open>
    <summary>polygon feature</summary>

```mermaid
classDiagram

    class PolygonProperty {
        model: str
        model_version: str
        reference_id: str = ''
        validated: bool = False
        confidence: Union[float, int, NoneType] = None
    }

    class PolygonFeatureCollection {
        type: GeoJsonType = GeoJsonType.FeatureCollection
        features: list[PolygonFeature] = list
    }

    class GeomType {
        <<Enumeration>>
        Point: str = 'Point'
        LineString: str = 'LineString'
        Polygon: str = 'Polygon'
    }

    class ModelProvenance {
        model: str
        model_version: str
        confidence: Union[float, int, NoneType] = None
    }

    class PolygonLegendAndFeaturesResult {
        id: str
        legend_provenance: Optional[ModelProvenance] = None
        label: str
        abbreviation: str = ''
        description: str = ''
        legend_bbox: list[Union[float, int]] = list
        legend_contour: list[list[Union[float, int]]] = list
        color: str = ''
        pattern: str = ''
        category: str = ''
        map_unit: Optional[MapUnit] = None
        reference_id: str = ''
        validated: bool = False
        crs: str = 'pixel'
        cdr_projection_id: str = ''
        polygon_features: Optional[PolygonFeatureCollection] = None
    }

    class PolygonFeature {
        type: GeoJsonType = GeoJsonType.Feature
        id: str
        geometry: Polygon
        properties: PolygonProperty
    }

    class Polygon {
        coordinates: list[list[list[Union[float, int]]]]
        type: GeomType = GeomType.Polygon
    }

    class MapUnit {
        age_text: str = ''
        b_age: Optional[float] = None
        b_interval: str = ''
        lithology: str = ''
        name: str = ''
        t_age: Optional[float] = None
        t_interval: str = ''
        comments: str = ''
    }

    class GeoJsonType {
        <<Enumeration>>
        Feature: str = 'Feature'
        FeatureCollection: str = 'FeatureCollection'
    }

    Polygon ..> GeomType
    PolygonFeature ..> GeoJsonType
    PolygonFeature ..> Polygon
    PolygonFeature ..> PolygonProperty
    PolygonFeatureCollection ..> PolygonFeature
    PolygonFeatureCollection ..> GeoJsonType
    PolygonLegendAndFeaturesResult ..> PolygonFeatureCollection
    PolygonLegendAndFeaturesResult ..> ModelProvenance
    PolygonLegendAndFeaturesResult ..> MapUnit


```

</details>

### Cog Metadata

<details open>
    <summary>cog metadata</summary>

```mermaid
classDiagram

    class MapMetaData {
        title: str = ''
        year: Optional[int] = None
        crs: str = ''
        authors: list[str] = list
        organization: str = ''
        scale: Optional[int] = None
        quadrangle_name: str = ''
        map_shape: Optional[MapShapeTypes] = None
        map_color_scheme: Optional[MapColorSchemeTypes] = None
        publisher: str = ''
        state: str = ''
        model: str
        model_version: str
    }

    class MapShapeTypes {
        <<Enumeration>>
        rectangular: str = 'rectangular'
        non_rectangular: str = 'non_rectangular'
    }

    class MapColorSchemeTypes {
        <<Enumeration>>
        full_color: str = 'full_color'
        monochrome: str = 'monochrome'
        grayscale: str = 'grayscale'
    }

    class CogMetaData {
        cog_id: str
        system: str
        system_version: str
        multiple_maps: Optional[bool] = None
        map_metadata: list[MapMetaData] = list
    }

    MapMetaData ..> MapShapeTypes
    MapMetaData ..> MapColorSchemeTypes
    CogMetaData ..> MapMetaData


```

</details>

### Document

<details open>
    <summary>document</summary>

```mermaid
classDiagram

    class DocumentProvenance {
        external_system_name: str
        external_system_id: str = ''
        external_system_url: str = ''
    }

    class DocumentMetaData {
        doi: str = ''
        authors: list[str] = list
        journal: str = ''
        year: Optional[int] = None
        month: Optional[int] = None
        volume: Optional[int] = None
        issue: str = ''
        description: str = ''
        publisher: str = ''
    }

    class Document {
        id: str
        title: str
        is_open: bool
        pages: int
        size: int
        provenance: list[DocumentProvenance] = list
        metadata: Optional[DocumentMetaData] = None
        system: str
        system_version: str
    }

    class UploadDocument {
        title: str
        is_open: bool = True
        provenance: list[DocumentProvenance] = list
        metadata: Optional[DocumentMetaData] = None
        system: str
        system_version: str
    }

    class DocumentExtraction {
        id: UnionType[str, NoneType] = None
        document_id: str = None
        extraction_type: str
        extraction_label: str
        score: UnionType[float, NoneType] = None
        bbox: UnionType[tuple[float, float, float, float], NoneType] = None
        page_num: UnionType[int, NoneType] = None
        external_link: UnionType[str, NoneType] = None
        data: Optional[dict[]] = None
        system: str
        system_version: str
    }

    UploadDocument ..> DocumentProvenance
    UploadDocument ..> DocumentMetaData
    Document ..> DocumentProvenance
    Document ..> DocumentMetaData


```

</details>

### Mineral

<details open>
    <summary>mineral</summary>

```mermaid
classDiagram

    class DepositTypeCandidate {
        observed_name: str
        name: str
        confidence: Union[float, int, NoneType]
        source: str
    }

    class DocumentReference {
        cdr_id: str
        page: Optional[int]
        x_min: Optional[float]
        x_max: Optional[float]
        y_min: Optional[float]
        y_max: Optional[float]
    }

    class MineralSite {
        id: str
        source_id: str
        record_id: str
        name: str = ''
        site_rank: str = ''
        site_type: str = ''
        country: list[str] = list
        province: list[str] = list
        location: Optional[GeoLocationInfo]
        mineral_inventory: list[MineralInventory] = list
        deposit_type_candidate: list[DepositTypeCandidate] = list
    }

    class MineralSystem {
        deposit_type: list[str] = list
        source: list[MappableCriteria]
        pathway: list[MappableCriteria]
        trap: list[MappableCriteria] = list
        preservation: list[MappableCriteria] = list
        energy: list[MappableCriteria] = list
        outflow: list[MappableCriteria] = list
    }

    class MappableCriteria {
        criteria: str
        theoretical: str = ''
        potential_dataset: list[EvidenceLayer] = list
        supporting_references: list[DocumentReference]
    }

    class EvidenceLayer {
        name: str = ''
        relevance_score: float
    }

    class RecordReference {
        record_id: str = ''
        source: str = ''
        uri: str = ''
    }

    class MineralInventoryCategory {
        category: str
        confidence: Union[float, int, NoneType]
        source: str
    }

    class GeologyInfo {
        age: str = ''
        unit_name: str = ''
        description: str = ''
        lithology: list[str] = list
        process: list[str] = list
        environment: list[str] = list
        comments: str = ''
    }

    class Confidence {
        confidence: Union[float, int, NoneType]
        source: str
    }

    class MineralInventory {
        contained_metal: Optional[float]
        commodity: str = ''
        commodity_observed_name: str = ''
        ore_unit: str = ''
        ore_value: Optional[float]
        grade_unit: str = ''
        grade_value: Optional[float]
        cutoff_grade_unit: str = ''
        cutoff_grade_value: Optional[float]
        material_form: Optional[float]
        material_form_unit: str = ''
        material_form_conversion: Optional[float]
        confidence: Confidence
        categories: list[MineralInventoryCategory] = list
        documents: list[DocumentReference] = list
        records: list[RecordReference] = list
        date: Optional[datetime]
        zone: str = ''
    }

    class GeoLocationInfo {
        crs: str
        geom: str
    }

    MappableCriteria ..> DocumentReference
    MappableCriteria ..> EvidenceLayer
    MineralSystem ..> MappableCriteria
    MineralInventory ..> DocumentReference
    MineralInventory ..> datetime
    MineralInventory ..> Confidence
    MineralInventory ..> RecordReference
    MineralInventory ..> MineralInventoryCategory
    MineralSite ..> DepositTypeCandidate
    MineralSite ..> MineralInventory
    MineralSite ..> GeoLocationInfo


```

</details>

### Map Results

<details open>
    <summary>map results</summary>

```mermaid
classDiagram

    class FeatureResults {
        system: str
        system_version: str
        cog_id: str
        line_feature_results: list[LineLegendAndFeaturesResult] = list
        point_feature_results: list[PointLegendAndFeaturesResult] = list
        polygon_feature_results: list[PolygonLegendAndFeaturesResult] = list
        cog_area_extractions: list[Area_Extraction] = list
        cog_metadata_extractions: list[CogMetaData] = list
    }

    class MapResults {
        cog_id: str
        georef_results: list[GeoreferenceResults] = list
        extraction_results: list[FeatureResults] = list
    }

    class GeoreferenceResults {
        cog_id: str
        georeference_results: list[GeoreferenceResult] = list
        gcps: list[GroundControlPoint] = list
        system: str
        system_version: str
    }

    FeatureResults ..> PolygonLegendAndFeaturesResult
    FeatureResults ..> PointLegendAndFeaturesResult
    FeatureResults ..> LineLegendAndFeaturesResult
    FeatureResults ..> CogMetaData
    FeatureResults ..> Area_Extraction
    GeoreferenceResults ..> GroundControlPoint
    GeoreferenceResults ..> GeoreferenceResult
    MapResults ..> FeatureResults
    MapResults ..> GeoreferenceResults


```

</details>

### Map

<details open>
    <summary>map</summary>

```mermaid
classDiagram

    class Map {
        id: str
        provenance: list[MapProvenance] = list
        is_open: bool
        system: str
        system_version: str
    }

    class MapProvenance {
        system_name: str
        id: str = None
        url: str = None
    }

    Map ..> MapProvenance


```

</details>

### Prospectivity Input

<details open>
    <summary>prospectivity input</summary>

```mermaid
classDiagram

    class ScalingType {
        <<Enumeration>>
        MINMAX: str = 'minmax'
        MAXABS: str = 'maxabs'
        STANDARD: str = 'standard'
    }

    class DataSource {
        DOI: Optional[str]
        authors: Optional[list[str]]
        publication_date: Optional[str]
        category: Union[LayerCategory, str, NoneType]
        subcategory: Optional[str]
        description: Optional[str]
        derivative_ops: Optional[str]
        type: LayerDataType
        resolution: Optional[tuple]
        format: DataFormat
        download_url: Optional[str]
    }

    class InterpolationType {
        <<Enumeration>>
        LINEAR: str = 'linear'
        CUBIC: str = 'cubic'
        NEAREST: str = 'nearest'
        NONE: str = 'none'
    }

    class DataFormat {
        <<Enumeration>>
        TIF: str = 'tif'
        SHP: str = 'shp'
    }

    class LayerDataType {
        <<Enumeration>>
        CONTINUOUS: str = 'continuous'
        BINARY: str = 'binary'
    }

    class StackMetaData {
        title: Optional[str]
        year: Optional[int]
        crs: Optional[str]
        authors: Optional[list[str]]
        organization: Optional[str]
        scale: Optional[int]
        evidence_layers: list[ProcessedDataLayer]
    }

    class ProcessedDataLayer {
        title: Optional[str]
        resampling_method: InterpolationType
        scaling_method: ScalingType
        normalization_method: str
    }

    class LayerCategory {
        <<Enumeration>>
        GEOPHYSICS: str = 'geophysics'
        GEOLOGY: str = 'geology'
        GEOCHEMISTRY: str = 'geochemistry'
    }

    DataSource ..> LayerDataType
    DataSource ..> DataFormat
    DataSource ..> LayerCategory
    DataSource ..> tuple
    ProcessedDataLayer ..> ScalingType
    ProcessedDataLayer ..> InterpolationType
    StackMetaData ..> ProcessedDataLayer


```

</details>

### Prospectivity Models

<details open>
    <summary>prospectivity models</summary>

```mermaid
classDiagram

    class SOMGrid {
        <<Enumeration>>
        HEXAGONAL: str = 'hexagonal'
        RECTANGULAR: str = 'rectangular'
    }

    class Accelerator {
        <<Enumeration>>
        CPU: str = 'cpu'
        GPU: str = 'gpu'
    }

    class NeighborhoodDecay {
        <<Enumeration>>
        LINEAR: str = 'linear'
        EXPONENTIAL: str = 'exponential'
    }

    class NeighborhoodFunction {
        <<Enumeration>>
        GAUSSIAN: str = 'gaussian'
        BUBBLE: str = 'bubble'
    }

    class SOMInitialization {
        <<Enumeration>>
        RANDOM: str = 'random'
        PCA: str = 'pca'
    }

    class NeuralNetTrainConfig {
        min_epochs: int
        max_epochs: int
        accelerator: Accelerator
        precision: int
        val_check_interval: float
        deterministic: bool
    }

    class SOMModel {
        train_config: SOMTrainConfig
    }

    class StackMetaData {
        title: Optional[str]
        year: Optional[int]
        crs: Optional[str]
        authors: Optional[list[str]]
        organization: Optional[str]
        scale: Optional[int]
        evidence_layers: list[ProcessedDataLayer]
    }

    class NeuralNetModel {
        train_config: NeuralNetTrainConfig
    }

    class SOMType {
        <<Enumeration>>
        TOROID: str = 'toroid'
        SHEET: str = 'sheet'
    }

    class SOMTrainConfig {
        dimensions_x: int
        dimensions_y: int
        num_epochs: int
        num_initializations: int
        neighborhood_function: NeighborhoodFunction
        som_type: SOMType
        neighborhood_decay: NeighborhoodDecay
        learning_rate_decay: LearningRateDecay
        initial_learning_rate: float
        final_learning_rate: float
        som_initialization: SOMInitialization
        som_grid: SOMGrid
    }

    class CMAModel {
        title: Optional[str]
        date: Optional[int]
        authors: Optional[list[str]]
        organization: Optional[str]
        cma_model_type: Union[NeuralNetModel, SOMModel]
        training_data: StackMetaData
    }

    class LearningRateDecay {
        <<Enumeration>>
        LINEAR: str = 'linear'
        EXPONENTIAL: str = 'exponential'
    }

    StackMetaData ..> ProcessedDataLayer
    NeuralNetTrainConfig ..> Accelerator
    SOMTrainConfig ..> SOMGrid
    SOMTrainConfig ..> SOMType
    SOMTrainConfig ..> NeighborhoodDecay
    SOMTrainConfig ..> NeighborhoodFunction
    SOMTrainConfig ..> SOMInitialization
    SOMTrainConfig ..> LearningRateDecay
    NeuralNetModel ..> NeuralNetTrainConfig
    SOMModel ..> SOMTrainConfig
    CMAModel ..> SOMModel
    CMAModel ..> NeuralNetModel
    CMAModel ..> StackMetaData


```

</details>
<!--#+END_SCHEMA-->




# CDR Schemas


## Development

Formatting Code
```
poetry run format
```


Verify Changes
```
# verify types (mypy)
poetry run types

# lint
poetry run lint
```

Build local package

```
poetry build -f sdist
```


Update Schema Diagrams

To generate schemas you will need to run `poetry install --with docs` to install the proper dependencies

```
poetry run docs
```

<!--#+BEGIN_SCHEMA-->
<!-- this sections is autogenerated -->



## Schemas

   [Area Extraction](#Area-Extraction)<br/>
   [Cog Metadata](#Cog-Metadata)<br/>
   [Document](#Document)<br/>
   [Feature Results](#Feature-Results)<br/>
   [Georeference](#Georeference)<br/>
   [Line Feature](#Line-Feature)<br/>
   [Map](#Map)<br/>
   [Map Results](#Map-Results)<br/>
   [Metadata](#Metadata)<br/>
   [Mineral](#Mineral)<br/>
   [Point Feature](#Point-Feature)<br/>
   [Polygon Feature](#Polygon-Feature)<br/>



### Area Extraction

<details open>
    <summary>area extraction</summary>

```mermaid
classDiagram

    class Area_Extraction {
        type: GeomType = GeomType.Polygon
        coordinates: list[list[list[Union[float, int]]]]
        bbox: list[Union[float, int]] = list
        category: AreaType
        text: Optional[str] = None
        model: Optional[str] = None
        model_version: Optional[str] = None
        confidence: Union[float, int, NoneType] = None
    }

    class GeomType {
        <<Enumeration>>
        Point: str = 'Point'
        LineString: str = 'LineString'
        Polygon: str = 'Polygon'
    }

    class AreaType {
        <<Enumeration>>
        Map_Area: str = 'map_area'
        Legend_Area: str = 'legend_area'
        CrossSection: str = 'cross_section'
        OCR: str = 'ocr'
        Polygon_Legend_Area: str = 'polygon_legend_area'
        Line_Point_Legend_Area: str = 'line_point_legend_area'
        Line_Legend_Area: str = 'line_legend_area'
        Point_Legend_Area: str = 'point_legend_area'
        Correlation_Diagram: str = 'correlation_diagram'
    }

    Area_Extraction ..> GeomType
    Area_Extraction ..> AreaType


```

</details>

### Georeference

<details open>
    <summary>georeference</summary>

```mermaid
classDiagram

    class Pixel_Point {
        rows_from_top: Union[float, int]
        columns_from_left: Union[float, int]
        type: GeomType = GeomType.Point
    }

    class GeoreferenceResult {
        likely_CRSs: list[str] = list
        map_area: Optional[Area_Extraction] = None
        projections: list[ProjectionResult] = list
    }

    class ProjectionResult {
        crs: str
        gcp_ids: list[str]
        file_name: str
    }

    class GroundControlPoint {
        gcp_id: str
        map_geom: Geom_Point
        px_geom: Pixel_Point
        confidence: Union[float, int, NoneType] = None
        model: str
        model_version: str
        crs: Optional[str]
    }

    class GeomType {
        <<Enumeration>>
        Point: str = 'Point'
        LineString: str = 'LineString'
        Polygon: str = 'Polygon'
    }

    class Area_Extraction {
        type: GeomType = GeomType.Polygon
        coordinates: list[list[list[Union[float, int]]]]
        bbox: list[Union[float, int]] = list
        category: AreaType
        text: Optional[str] = None
        model: Optional[str] = None
        model_version: Optional[str] = None
        confidence: Union[float, int, NoneType] = None
    }

    class Geom_Point {
        latitude: Union[float, int, NoneType]
        longitude: Union[float, int, NoneType]
        type: GeomType = GeomType.Point
    }

    class GeoreferenceResults {
        cog_id: str
        georeference_results: list[GeoreferenceResult] = list
        gcps: list[GroundControlPoint] = list
        system: str
        system_version: str
    }

    Area_Extraction ..> GeomType
    Area_Extraction ..> AreaType
    Geom_Point ..> GeomType
    Pixel_Point ..> GeomType
    GroundControlPoint ..> Pixel_Point
    GroundControlPoint ..> Geom_Point
    GeoreferenceResult ..> Area_Extraction
    GeoreferenceResult ..> ProjectionResult
    GeoreferenceResults ..> GroundControlPoint
    GeoreferenceResults ..> GeoreferenceResult


```

</details>

### Metadata

<details open>
    <summary>metadata</summary>

```mermaid
classDiagram

    class MapShapeTypes {
        <<Enumeration>>
        rectangular: str = 'rectangular'
        non_rectangular: str = 'non_rectangular'
    }

    class CogMetaData {
        cog_id: str
        system: str
        system_version: str
        multiple_maps: Optional[bool] = None
        map_metadata: list[MapMetaData] = list
    }

    class MapMetaData {
        title: Optional[str] = None
        year: Optional[int] = None
        crs: Optional[str] = None
        authors: list[str] = list
        organization: Optional[str] = None
        scale: Optional[int] = None
        quadrangle_name: Optional[str] = None
        map_shape: Optional[MapShapeTypes] = None
        map_color_scheme: Optional[MapColorSchemeTypes] = None
        publisher: Optional[str] = None
        state: Optional[str] = None
        model: str
        model_version: str
    }

    class MapColorSchemeTypes {
        <<Enumeration>>
        full_color: str = 'full_color'
        monochrome: str = 'monochrome'
        grayscale: str = 'grayscale'
    }

    MapMetaData ..> MapShapeTypes
    MapMetaData ..> MapColorSchemeTypes
    CogMetaData ..> MapMetaData


```

</details>

### Feature Results

<details open>
    <summary>feature results</summary>

```mermaid
classDiagram

    class PointLegendAndFeaturesResult {
        id: str
        legend_provenance: Optional[ModelProvenance] = None
        name: Optional[str] = None
        abbreviation: Optional[str] = None
        description: Optional[str] = None
        legend_bbox: list[Union[float, int]] = list
        legend_contour: list[list[Union[float, int]]] = list
        crs: Optional[str] = 'pixel'
        cdr_projection_id: Optional[str] = None
        point_features: Optional[PointFeatureCollection] = None
    }

    class CogMetaData {
        cog_id: str
        system: str
        system_version: str
        multiple_maps: Optional[bool] = None
        map_metadata: list[MapMetaData] = list
    }

    class FeatureResults {
        system: str
        system_version: str
        cog_id: str
        line_feature_results: list[LineLegendAndFeaturesResult] = list
        point_feature_results: list[PointLegendAndFeaturesResult] = list
        polygon_feature_results: list[PolygonLegendAndFeaturesResult] = list
        cog_area_extractions: list[Area_Extraction] = list
        cog_metadata_extractions: list[CogMetaData] = list
    }

    class PolygonLegendAndFeaturesResult {
        id: str
        legend_provenance: Optional[ModelProvenance] = None
        label: Optional[str] = None
        abbreviation: Optional[str] = None
        description: Optional[str] = None
        legend_bbox: list[Union[float, int]] = list
        legend_contour: list[list[Union[float, int]]] = list
        color: Optional[str] = None
        pattern: Optional[str] = None
        category: Optional[str] = None
        map_unit: Optional[MapUnit] = None
        crs: Optional[str] = 'pixel'
        cdr_projection_id: Optional[str] = None
        polygon_features: Optional[PolygonFeatureCollection] = None
    }

    class Area_Extraction {
        type: GeomType = GeomType.Polygon
        coordinates: list[list[list[Union[float, int]]]]
        bbox: list[Union[float, int]] = list
        category: AreaType
        text: Optional[str] = None
        model: Optional[str] = None
        model_version: Optional[str] = None
        confidence: Union[float, int, NoneType] = None
    }

    class LineLegendAndFeaturesResult {
        id: str
        legend_provenance: Optional[ModelProvenance] = None
        name: Optional[str] = None
        abbreviation: Optional[str] = None
        description: Optional[str] = None
        legend_bbox: list[Union[float, int]] = list
        legend_contour: list[list[Union[float, int]]] = list
        crs: Optional[str] = 'pixel'
        cdr_projection_id: Optional[str] = None
        line_features: Optional[LineFeatureCollection] = None
    }

    Area_Extraction ..> GeomType
    Area_Extraction ..> AreaType
    LineLegendAndFeaturesResult ..> ModelProvenance
    LineLegendAndFeaturesResult ..> LineFeatureCollection
    PointLegendAndFeaturesResult ..> ModelProvenance
    PointLegendAndFeaturesResult ..> PointFeatureCollection
    PolygonLegendAndFeaturesResult ..> PolygonFeatureCollection
    PolygonLegendAndFeaturesResult ..> MapUnit
    PolygonLegendAndFeaturesResult ..> ModelProvenance
    CogMetaData ..> MapMetaData
    FeatureResults ..> PointLegendAndFeaturesResult
    FeatureResults ..> CogMetaData
    FeatureResults ..> PolygonLegendAndFeaturesResult
    FeatureResults ..> Area_Extraction
    FeatureResults ..> LineLegendAndFeaturesResult


```

</details>

### Point Feature

<details open>
    <summary>point feature</summary>

```mermaid
classDiagram

    class PointLegendAndFeaturesResult {
        id: str
        legend_provenance: Optional[ModelProvenance] = None
        name: Optional[str] = None
        abbreviation: Optional[str] = None
        description: Optional[str] = None
        legend_bbox: list[Union[float, int]] = list
        legend_contour: list[list[Union[float, int]]] = list
        crs: Optional[str] = 'pixel'
        cdr_projection_id: Optional[str] = None
        point_features: Optional[PointFeatureCollection] = None
    }

    class Point {
        coordinates: list[Union[float, int]]
        type: GeomType = GeomType.Point
    }

    class PointProperties {
        model: Optional[str] = None
        model_version: Optional[str] = None
        confidence: Union[float, int, NoneType] = None
        bbox: Optional[list[Union[float, int]]] = None
        dip: Optional[int] = None
        dip_direction: Optional[int] = None
    }

    class GeomType {
        <<Enumeration>>
        Point: str = 'Point'
        LineString: str = 'LineString'
        Polygon: str = 'Polygon'
    }

    class ModelProvenance {
        model: Optional[str] = None
        model_version: Optional[str] = None
        confidence: Union[float, int, NoneType] = None
    }

    class PointFeatureCollection {
        type: GeoJsonType = GeoJsonType.FeatureCollection
        features: list[PointFeature] = list
    }

    class GeoJsonType {
        <<Enumeration>>
        Feature: str = 'Feature'
        FeatureCollection: str = 'FeatureCollection'
    }

    class PointFeature {
        type: GeoJsonType = GeoJsonType.Feature
        id: str
        geometry: Point
        properties: PointProperties
    }

    Point ..> GeomType
    PointFeature ..> PointProperties
    PointFeature ..> Point
    PointFeature ..> GeoJsonType
    PointFeatureCollection ..> PointFeature
    PointFeatureCollection ..> GeoJsonType
    PointLegendAndFeaturesResult ..> ModelProvenance
    PointLegendAndFeaturesResult ..> PointFeatureCollection


```

</details>

### Line Feature

<details open>
    <summary>line feature</summary>

```mermaid
classDiagram

    class LineProperty {
        model: Optional[str] = None
        model_version: Optional[str] = None
        confidence: Union[float, int, NoneType] = None
        dash_pattern: Optional[DashType] = None
        symbol: Optional[str] = None
    }

    class DashType {
        <<Enumeration>>
        solid: str = 'solid'
        dash: str = 'dash'
        dotted: str = 'dotted'
    }

    class Line {
        coordinates: list[list[Union[float, int]]]
        type: GeomType = GeomType.LineString
    }

    class GeomType {
        <<Enumeration>>
        Point: str = 'Point'
        LineString: str = 'LineString'
        Polygon: str = 'Polygon'
    }

    class ModelProvenance {
        model: Optional[str] = None
        model_version: Optional[str] = None
        confidence: Union[float, int, NoneType] = None
    }

    class LineFeature {
        type: GeoJsonType = GeoJsonType.Feature
        id: str
        geometry: Line
        properties: LineProperty
    }

    class LineFeatureCollection {
        type: GeoJsonType = GeoJsonType.FeatureCollection
        features: list[LineFeature] = list
    }

    class GeoJsonType {
        <<Enumeration>>
        Feature: str = 'Feature'
        FeatureCollection: str = 'FeatureCollection'
    }

    class LineLegendAndFeaturesResult {
        id: str
        legend_provenance: Optional[ModelProvenance] = None
        name: Optional[str] = None
        abbreviation: Optional[str] = None
        description: Optional[str] = None
        legend_bbox: list[Union[float, int]] = list
        legend_contour: list[list[Union[float, int]]] = list
        crs: Optional[str] = 'pixel'
        cdr_projection_id: Optional[str] = None
        line_features: Optional[LineFeatureCollection] = None
    }

    Line ..> GeomType
    LineProperty ..> DashType
    LineFeature ..> LineProperty
    LineFeature ..> Line
    LineFeature ..> GeoJsonType
    LineFeatureCollection ..> LineFeature
    LineFeatureCollection ..> GeoJsonType
    LineLegendAndFeaturesResult ..> ModelProvenance
    LineLegendAndFeaturesResult ..> LineFeatureCollection


```

</details>

### Polygon Feature

<details open>
    <summary>polygon feature</summary>

```mermaid
classDiagram

    class PolygonFeature {
        type: GeoJsonType = GeoJsonType.Feature
        id: str
        geometry: Polygon
        properties: PolygonProperty
    }

    class PolygonProperty {
        model: Optional[str] = None
        model_version: Optional[str] = None
        confidence: Union[float, int, NoneType] = None
    }

    class PolygonFeatureCollection {
        type: GeoJsonType = GeoJsonType.FeatureCollection
        features: list[PolygonFeature] = list
    }

    class MapUnit {
        age_text: Optional[str] = None
        b_age: Optional[float] = None
        b_interval: Optional[str] = None
        lithology: Optional[str] = None
        name: Optional[str] = None
        t_age: Optional[float] = None
        t_interval: Optional[str] = None
        comments: Optional[str] = None
    }

    class GeomType {
        <<Enumeration>>
        Point: str = 'Point'
        LineString: str = 'LineString'
        Polygon: str = 'Polygon'
    }

    class ModelProvenance {
        model: Optional[str] = None
        model_version: Optional[str] = None
        confidence: Union[float, int, NoneType] = None
    }

    class Polygon {
        coordinates: list[list[list[Union[float, int]]]]
        type: GeomType = GeomType.Polygon
    }

    class GeoJsonType {
        <<Enumeration>>
        Feature: str = 'Feature'
        FeatureCollection: str = 'FeatureCollection'
    }

    class PolygonLegendAndFeaturesResult {
        id: str
        legend_provenance: Optional[ModelProvenance] = None
        label: Optional[str] = None
        abbreviation: Optional[str] = None
        description: Optional[str] = None
        legend_bbox: list[Union[float, int]] = list
        legend_contour: list[list[Union[float, int]]] = list
        color: Optional[str] = None
        pattern: Optional[str] = None
        category: Optional[str] = None
        map_unit: Optional[MapUnit] = None
        crs: Optional[str] = 'pixel'
        cdr_projection_id: Optional[str] = None
        polygon_features: Optional[PolygonFeatureCollection] = None
    }

    Polygon ..> GeomType
    PolygonFeature ..> PolygonProperty
    PolygonFeature ..> Polygon
    PolygonFeature ..> GeoJsonType
    PolygonFeatureCollection ..> PolygonFeature
    PolygonFeatureCollection ..> GeoJsonType
    PolygonLegendAndFeaturesResult ..> PolygonFeatureCollection
    PolygonLegendAndFeaturesResult ..> MapUnit
    PolygonLegendAndFeaturesResult ..> ModelProvenance


```

</details>

### Cog Metadata

<details open>
    <summary>cog metadata</summary>

```mermaid
classDiagram

    class MapShapeTypes {
        <<Enumeration>>
        rectangular: str = 'rectangular'
        non_rectangular: str = 'non_rectangular'
    }

    class CogMetaData {
        cog_id: str
        system: str
        system_version: str
        multiple_maps: Optional[bool] = None
        map_metadata: list[MapMetaData] = list
    }

    class MapMetaData {
        title: Optional[str] = None
        year: Optional[int] = None
        crs: Optional[str] = None
        authors: list[str] = list
        organization: Optional[str] = None
        scale: Optional[int] = None
        quadrangle_name: Optional[str] = None
        map_shape: Optional[MapShapeTypes] = None
        map_color_scheme: Optional[MapColorSchemeTypes] = None
        publisher: Optional[str] = None
        state: Optional[str] = None
        model: str
        model_version: str
    }

    class MapColorSchemeTypes {
        <<Enumeration>>
        full_color: str = 'full_color'
        monochrome: str = 'monochrome'
        grayscale: str = 'grayscale'
    }

    MapMetaData ..> MapShapeTypes
    MapMetaData ..> MapColorSchemeTypes
    CogMetaData ..> MapMetaData


```

</details>

### Document

<details open>
    <summary>document</summary>

```mermaid
classDiagram

    class DocumentMetaData {
        doi: str = ''
        authors: list[str] = list
        journal: str = ''
        year: Optional[int] = None
        month: Optional[int] = None
        volume: Optional[int] = None
        issue: Optional[int] = None
        description: str = ''
    }

    class Document {
        id: str
        title: str
        is_open: bool
        pages: int
        size: int
        provenance: list[DocumentProvenance] = list
        metadata: Optional[DocumentMetaData] = None
        system: str
        system_version: str
    }

    class DocumentExtraction {
        id: UnionType[str, NoneType] = None
        document_id: str = None
        extraction_type: str
        extraction_label: str
        score: UnionType[float, NoneType] = None
        bbox: UnionType[tuple[float, float, float, float], NoneType] = None
        page_num: UnionType[int, NoneType] = None
        external_link: UnionType[str, NoneType] = None
        data: Optional[dict[]] = None
        system: str
        system_version: str
    }

    class DocumentProvenance {
        external_system_name: str
        external_system_id: Optional[str] = ''
        external_system_url: Optional[str] = ''
    }

    class UploadDocument {
        title: str
        is_open: bool = True
        provenance: Optional[DocumentProvenance] = None
        metadata: Optional[DocumentMetaData] = None
        system: str
        system_version: str
    }

    UploadDocument ..> DocumentMetaData
    UploadDocument ..> DocumentProvenance
    Document ..> DocumentMetaData
    Document ..> DocumentProvenance


```

</details>

### Mineral

<details open>
    <summary>mineral</summary>

```mermaid
classDiagram

    class MappableCriteria {
        criteria: str
        theoretical: Optional[str]
        potential_dataset: list[EvidenceLayer] = list
        supporting_references: list[Reference] = list
    }

    class LocationInfo {
        location: Geometry
        crs: str
        country: Optional[str]
        state_or_province: Optional[str]
    }

    class Geometry {
        <<Enumeration>>
        Point: str = 'Point'
        Polygon: str = 'Polygon'
    }

    class EvidenceLayer {
        name: str
        relevance_score: float
    }

    class BoundingBox {
        x_min: float
        x_max: float
        y_min: float
        y_max: float
    }

    class PageInfo {
        page: int
        bounding_box: Optional[BoundingBox]
    }

    class MineralInventory {
        commodity: Commodity
        observed_commodity: Optional[str]
        category: Optional[ResourceReserveCategory]
        ore: Optional[Ore]
        grade: Optional[Grade]
        cutoff_grade: Optional[Grade]
        contained_metal: Optional[float]
        reference: Reference
        date: Optional[datetime]
        zone: Optional[str]
    }

    class Document {
        id: str
        title: str
        is_open: bool
        pages: int
        size: int
        provenance: list[DocumentProvenance] = list
        metadata: Optional[DocumentMetaData] = None
        system: str
        system_version: str
    }

    class Ore {
        ore_unit: str
        ore_value: float
    }

    class Commodity {
        name: str
    }

    class MineralSite {
        source_id: str
        record_id: str
        name: Optional[str]
        mineral_inventory: list[MineralInventory]
        location_info: LocationInfo
        geology_info: Optional[GeologyInfo]
        deposit_type_candidate: list[DepositTypeCandidate]
    }

    class ResourceReserveCategory {
        <<Enumeration>>
        INFERRED: str = 'Inferred Mineral Resource'
        INDICATED: str = 'Indicated Mineral Resource'
        MEASURED: str = 'Measured Mineral Resource'
        PROBABLE: str = 'Probable Mineral Reserve'
        PROVEN: str = 'Proven Mineral Reserve'
    }

    class Reference {
        document: Document
        page_info: list[PageInfo] = list
    }

    class MineralSystem {
        deposit_type: list[DepositType]
        source: list[MappableCriteria]
        pathway: list[MappableCriteria]
        trap: list[MappableCriteria] = list
        preservation: list[MappableCriteria] = list
        energy: list[MappableCriteria] = list
        outflow: list[MappableCriteria] = list
    }

    class DepositTypeCandidate {
        observed_name: str
        normalized_uri: DepositType
        confidence: Union[float, int, NoneType]
        source: str
    }

    class DepositType {
        name: str
        environment: str
        group: str
    }

    class Grade {
        grade_unit: str
        grade_value: float
    }

    class GeologyInfo {
        age: Optional[str]
        unit_name: Optional[str]
        description: Optional[str]
        lithology: list[str] = list
        process: list[str] = list
        environment: list[str] = list
        comments: Optional[str]
    }

    Document ..> DocumentMetaData
    Document ..> DocumentProvenance
    DepositTypeCandidate ..> DepositType
    PageInfo ..> BoundingBox
    Reference ..> PageInfo
    Reference ..> Document
    MappableCriteria ..> Reference
    MappableCriteria ..> EvidenceLayer
    MineralSystem ..> MappableCriteria
    MineralSystem ..> DepositType
    MineralInventory ..> ResourceReserveCategory
    MineralInventory ..> Reference
    MineralInventory ..> Ore
    MineralInventory ..> Grade
    MineralInventory ..> Commodity
    MineralInventory ..> datetime
    LocationInfo ..> Geometry
    MineralSite ..> GeologyInfo
    MineralSite ..> MineralInventory
    MineralSite ..> LocationInfo
    MineralSite ..> DepositTypeCandidate


```

</details>

### Map Results

<details open>
    <summary>map results</summary>

```mermaid
classDiagram

    class MapResults {
        cog_id: str
        georef_results: list[GeoreferenceResults] = list
        extraction_results: list[FeatureResults] = list
    }

    class GeoreferenceResults {
        cog_id: str
        georeference_results: list[GeoreferenceResult] = list
        gcps: list[GroundControlPoint] = list
        system: str
        system_version: str
    }

    class FeatureResults {
        system: str
        system_version: str
        cog_id: str
        line_feature_results: list[LineLegendAndFeaturesResult] = list
        point_feature_results: list[PointLegendAndFeaturesResult] = list
        polygon_feature_results: list[PolygonLegendAndFeaturesResult] = list
        cog_area_extractions: list[Area_Extraction] = list
        cog_metadata_extractions: list[CogMetaData] = list
    }

    FeatureResults ..> PointLegendAndFeaturesResult
    FeatureResults ..> CogMetaData
    FeatureResults ..> PolygonLegendAndFeaturesResult
    FeatureResults ..> Area_Extraction
    FeatureResults ..> LineLegendAndFeaturesResult
    GeoreferenceResults ..> GroundControlPoint
    GeoreferenceResults ..> GeoreferenceResult
    MapResults ..> GeoreferenceResults
    MapResults ..> FeatureResults


```

</details>

### Map

<details open>
    <summary>map</summary>

```mermaid
classDiagram

    class MapProvenance {
        system_name: str
        id: str = None
        url: str = None
    }

    class Map {
        id: str
        provenance: list[MapProvenance] = list
        is_open: bool
        system: str
        system_version: str
    }

    Map ..> MapProvenance


```

</details>
<!--#+END_SCHEMA-->
